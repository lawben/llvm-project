; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -mtriple=aarch64 -mattr=+sve < %s | FileCheck %s

define <vscale x 2 x i8> @test_compress_nxv2i8(<vscale x 2 x i8> %vec, <vscale x 2 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv2i8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    ret
    %out = call <vscale x 2 x i8> @llvm.masked.compress(<vscale x 2 x i8> %vec, <vscale x 2 x i1> %mask)
    ret <vscale x 2 x i8> %out
}

define <vscale x 2 x i16> @test_compress_nxv2i16(<vscale x 2 x i16> %vec, <vscale x 2 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv2i16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    ret
    %out = call <vscale x 2 x i16> @llvm.masked.compress(<vscale x 2 x i16> %vec, <vscale x 2 x i1> %mask)
    ret <vscale x 2 x i16> %out
}

define <vscale x 2 x i32> @test_compress_nxv2i32(<vscale x 2 x i32> %vec, <vscale x 2 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv2i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    ret
    %out = call <vscale x 2 x i32> @llvm.masked.compress(<vscale x 2 x i32> %vec, <vscale x 2 x i1> %mask)
    ret <vscale x 2 x i32> %out
}

define <vscale x 2 x i64> @test_compress_nxv2i64(<vscale x 2 x i64> %vec, <vscale x 2 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv2i64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    ret
    %out = call <vscale x 2 x i64> @llvm.masked.compress(<vscale x 2 x i64> %vec, <vscale x 2 x i1> %mask)
    ret <vscale x 2 x i64> %out
}

define <vscale x 2 x float> @test_compress_nxv2f32(<vscale x 2 x float> %vec, <vscale x 2 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv2f32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    ret
    %out = call <vscale x 2 x float> @llvm.masked.compress(<vscale x 2 x float> %vec, <vscale x 2 x i1> %mask)
    ret <vscale x 2 x float> %out
}

define <vscale x 2 x double> @test_compress_nxv2f64(<vscale x 2 x double> %vec, <vscale x 2 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv2f64:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.d, p0, z0.d
; CHECK-NEXT:    ret
    %out = call <vscale x 2 x double> @llvm.masked.compress(<vscale x 2 x double> %vec, <vscale x 2 x i1> %mask)
    ret <vscale x 2 x double> %out
}

define <vscale x 4 x i8> @test_compress_nxv4i8(<vscale x 4 x i8> %vec, <vscale x 4 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv4i8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.s, p0, z0.s
; CHECK-NEXT:    ret
    %out = call <vscale x 4 x i8> @llvm.masked.compress(<vscale x 4 x i8> %vec, <vscale x 4 x i1> %mask)
    ret <vscale x 4 x i8> %out
}

define <vscale x 4 x i16> @test_compress_nxv4i16(<vscale x 4 x i16> %vec, <vscale x 4 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv4i16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.s, p0, z0.s
; CHECK-NEXT:    ret
    %out = call <vscale x 4 x i16> @llvm.masked.compress(<vscale x 4 x i16> %vec, <vscale x 4 x i1> %mask)
    ret <vscale x 4 x i16> %out
}

define <vscale x 4 x i32> @test_compress_nxv4i32(<vscale x 4 x i32> %vec, <vscale x 4 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv4i32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.s, p0, z0.s
; CHECK-NEXT:    ret
    %out = call <vscale x 4 x i32> @llvm.masked.compress(<vscale x 4 x i32> %vec, <vscale x 4 x i1> %mask)
    ret <vscale x 4 x i32> %out
}

define <vscale x 4 x float> @test_compress_nxv4f32(<vscale x 4 x float> %vec, <vscale x 4 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv4f32:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.s, p0, z0.s
; CHECK-NEXT:    ret
    %out = call <vscale x 4 x float> @llvm.masked.compress(<vscale x 4 x float> %vec, <vscale x 4 x i1> %mask)
    ret <vscale x 4 x float> %out
}

define <vscale x 8 x i8> @test_compress_nxv8i8(<vscale x 8 x i8> %vec, <vscale x 8 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv8i8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    addvl sp, sp, #-1
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0c, 0x8f, 0x00, 0x11, 0x10, 0x22, 0x11, 0x08, 0x92, 0x2e, 0x00, 0x1e, 0x22 // sp + 16 + 8 * VG
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    ptrue p1.h
; CHECK-NEXT:    st1b { z0.h }, p0, [sp, #1, mul vl]
; CHECK-NEXT:    ld1b { z0.h }, p1/z, [sp, #1, mul vl]
; CHECK-NEXT:    addvl sp, sp, #1
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    ret
    %out = call <vscale x 8 x i8> @llvm.masked.compress(<vscale x 8 x i8> %vec, <vscale x 8 x i1> %mask)
    ret <vscale x 8 x i8> %out
}

define <vscale x 8 x i16> @test_compress_nxv8i16(<vscale x 8 x i16> %vec, <vscale x 8 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv8i16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    addvl sp, sp, #-1
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0c, 0x8f, 0x00, 0x11, 0x10, 0x22, 0x11, 0x08, 0x92, 0x2e, 0x00, 0x1e, 0x22 // sp + 16 + 8 * VG
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    ptrue p1.h
; CHECK-NEXT:    st1h { z0.h }, p0, [sp]
; CHECK-NEXT:    ld1h { z0.h }, p1/z, [sp]
; CHECK-NEXT:    addvl sp, sp, #1
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    ret
    %out = call <vscale x 8 x i16> @llvm.masked.compress(<vscale x 8 x i16> %vec, <vscale x 8 x i1> %mask)
    ret <vscale x 8 x i16> %out
}

define <vscale x 16 x i8> @test_compress_nxv16i8(<vscale x 16 x i8> %vec, <vscale x 16 x i1> %mask) {
; CHECK-LABEL: test_compress_nxv16i8:
; CHECK:       // %bb.0:
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    addvl sp, sp, #-1
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0c, 0x8f, 0x00, 0x11, 0x10, 0x22, 0x11, 0x08, 0x92, 0x2e, 0x00, 0x1e, 0x22 // sp + 16 + 8 * VG
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    ptrue p1.b
; CHECK-NEXT:    st1b { z0.b }, p0, [sp]
; CHECK-NEXT:    ld1b { z0.b }, p1/z, [sp]
; CHECK-NEXT:    addvl sp, sp, #1
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    ret
    %out = call <vscale x 16 x i8> @llvm.masked.compress(<vscale x 16 x i8> %vec, <vscale x 16 x i1> %mask)
    ret <vscale x 16 x i8> %out
}


define void @cs16(<vscale x 16 x i8> %vec, ptr %ptr, <vscale x 16 x i1> %mask) {
; CHECK-LABEL: cs16:
; CHECK:       // %bb.0:
; CHECK-NEXT:    st1b { z0.b }, p0, [x0]
; CHECK-NEXT:    ret
    call void @llvm.masked.compressstore(<vscale x 16 x i8> %vec, ptr %ptr, <vscale x 16 x i1> %mask)
    ret void
}

define <vscale x 4 x i4> @test_compress_illegal_element_type(<vscale x 4 x i4> %vec, <vscale x 4 x i1> %mask) {
; CHECK-LABEL: test_compress_illegal_element_type:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.s, p0, z0.s
; CHECK-NEXT:    ret
    %out = call <vscale x 4 x i4> @llvm.masked.compress(<vscale x 4 x i4> %vec, <vscale x 4 x i1> %mask)
    ret <vscale x 4 x i4> %out
}

define <vscale x 8 x i32> @test_compress_large(<vscale x 8 x i32> %vec, <vscale x 8 x i1> %mask) {
; CHECK-LABEL: test_compress_large:
; CHECK:       // %bb.0:
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    addvl sp, sp, #-2
; CHECK-NEXT:    .cfi_escape 0x0f, 0x0c, 0x8f, 0x00, 0x11, 0x10, 0x22, 0x11, 0x10, 0x92, 0x2e, 0x00, 0x1e, 0x22 // sp + 16 + 16 * VG
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    punpklo p2.h, p0.b
; CHECK-NEXT:    cnth x9
; CHECK-NEXT:    ptrue p1.s
; CHECK-NEXT:    sub x9, x9, #1
; CHECK-NEXT:    mov z2.s, p2/z, #1 // =0x1
; CHECK-NEXT:    punpkhi p0.h, p0.b
; CHECK-NEXT:    compact z0.s, p2, z0.s
; CHECK-NEXT:    compact z1.s, p0, z1.s
; CHECK-NEXT:    uaddv d2, p1, z2.s
; CHECK-NEXT:    st1w { z0.s }, p1, [sp]
; CHECK-NEXT:    fmov x8, d2
; CHECK-NEXT:    and x8, x8, #0xffffffff
; CHECK-NEXT:    cmp x8, x9
; CHECK-NEXT:    csel x8, x8, x9, lo
; CHECK-NEXT:    mov x9, sp
; CHECK-NEXT:    st1w { z1.s }, p1, [x9, x8, lsl #2]
; CHECK-NEXT:    ld1w { z0.s }, p1/z, [sp]
; CHECK-NEXT:    ld1w { z1.s }, p1/z, [sp, #1, mul vl]
; CHECK-NEXT:    addvl sp, sp, #2
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    ret
    %out = call <vscale x 8 x i32> @llvm.masked.compress(<vscale x 8 x i32> %vec, <vscale x 8 x i1> %mask)
    ret <vscale x 8 x i32> %out
}

;define <vscale x 3 x i32> @test_compress_narrow(<vscale x 3 x i32> %vec, <vscale x 3 x i1> %mask) {
;    %out = call <vscale x 3 x i32> @llvm.masked.compress(<vscale x 3 x i32> %vec, <vscale x 3 x i1> %mask)
;    ret <vscale x 3 x i32> %out
;}

;define <vscale x 3 x i3> @test_compress_narrow_illegal_element_type(<vscale x 3 x i3> %vec, <vscale x 3 x i1> %mask) {
;    %out = call <vscale x 3 x i3> @llvm.masked.compress(<vscale x 3 x i3> %vec, <vscale x 3 x i1> %mask)
;    ret <vscale x 3 x i3> %out
;}

; We pass a placeholder value for the const_mask* tests to check that they are converted to a no-op by simply copying
; the second vector input register to the ret register or doing nothing.
define <vscale x 4 x i32> @test_compress_const_splat1_mask(<vscale x 4 x i32> %ignore, <vscale x 4 x i32> %vec) {
; CHECK-LABEL: test_compress_const_splat1_mask:
; CHECK:       // %bb.0:
; CHECK-NEXT:    mov z0.d, z1.d
; CHECK-NEXT:    ret
    %out = call <vscale x 4 x i32> @llvm.masked.compress(<vscale x 4 x i32> %vec, <vscale x 4 x i1> splat (i1 -1))
    ret <vscale x 4 x i32> %out
}
define <vscale x 4 x i32> @test_compress_const_splat0_mask(<vscale x 4 x i32> %ignore, <vscale x 4 x i32> %vec) {
; CHECK-LABEL: test_compress_const_splat0_mask:
; CHECK:       // %bb.0:
; CHECK-NEXT:    ret
    %out = call <vscale x 4 x i32> @llvm.masked.compress(<vscale x 4 x i32> %vec, <vscale x 4 x i1> splat (i1 0))
    ret <vscale x 4 x i32> %out
}
define <vscale x 4 x i32> @test_compress_undef_mask(<vscale x 4 x i32> %ignore, <vscale x 4 x i32> %vec) {
; CHECK-LABEL: test_compress_undef_mask:
; CHECK:       // %bb.0:
; CHECK-NEXT:    compact z0.s, p0, z1.s
; CHECK-NEXT:    ret
    %out = call <vscale x 4 x i32> @llvm.masked.compress(<vscale x 4 x i32> %vec, <vscale x 4 x i1> undef)
    ret <vscale x 4 x i32> %out
}

;define void @test_compress_store_nxv16i8(<vscale x 16 x i8> %vec, <vscale x 16 x i1> %mask, ptr %ptr) {
;    %out = call <vscale x 16 x i8> @llvm.masked.compress(<vscale x 16 x i8> %vec, <vscale x 16 x i1> %mask)
;    store <vscale x 16 x i8> %out, ptr %ptr
;    ret void
;}
